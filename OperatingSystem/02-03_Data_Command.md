## Ch02 데이터
- 컴퓨터는 0과 1로 표현된 정보만 이해할 수 있다.
- 0과 1을 나타내는 가장 작은 정보 단위를 비트(bit)라고 한다.
- n비트로 표현할 수 있는 정보의 수는 2^n개 이다.
- 바이트(Byte)는 8비트, 1Byte(1B) = 8bit(8b)
- 킬로바이트(kB), 메가바이트(MB), 기가바이트(GB), 테라바이트(TB)
- 워드(word): cpu가 한번에 처리할 수 있는 데이터 크기 ex)32bit, 64bit

### 0과 1로 숫자를 표현하는 방법
**2진법**
- 컴퓨터는 0과 1로 수를 표현하는 이진수를 사용한다.
- 음수는 2의 보수로 표현하고 맨 앞의 비트를 부호를 나타내는 플래그로 사용한다.

**16진법**
- 2진수로 표현한 숫자는 길이가 너무 길어지기 때문에 16진법도 자주 사용한다.
- 10진수 대신 16진수를 사용하는 이유는 2진수를 16진수로 변환하기 쉽기 때문이다.
- 0~15의 수를 16진수는 한 자리로 표현하고 2진수는 네 자리로 표현할 수 있다.
- 따라서 2진수 네 자리인 4bit를 16진수 하나로 나타낼 수 있다.

### 0과 1로 문자를 표현하는 방법
- 문자 집합: 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
- 문자 인코딩: 문자 집합에 속한 문자를 0과 1로 이루어진 문자코드로 변환하는 과정
- 문자 디코딩: 0과 1로 표현된 문자 코드를 문자 집합의 문자로 변환하는 과정
- 코드 포인트: 글자에 부여된 고유한 값

**아스키 코드**
- 초창기 문자 집합 중 하나로 영어 알파벳과 아라비아 숫자, 일부 특수 문자 포함
- 아스키 문자는 7비트로 표현되기 때문에 총 128개의 문자를 표현 가능
- 아스키 코드: 아스키 문자에 대응(인코딩)된 고유한 수

**EUC-KR**
- 한글 인코딩인 하나의 글자에 코드를 부여하는 완성형 인코딩 방식
- 한글 한 글자에 2바이트 크기(16진수 4자리)의 코드를 부여

**유니코드/UTF-8**
- 유니코드는 대부분 나라의 문자와 특수문자, 이모티콘 등을 포함한 통일된 문자 집합
- UTF(Unicode Transformation Format)은 유니코드 문자에 부여된 값을 인코딩하는 것
- UTF-8을 주로 사용하며 인코딩한 결과는 코드 포인트에 따라 1~4 바이트로 표현됨

## Ch03 명령어
### 소스코드와 명령어
- 사람을 위한 언어는 고급 언어, 컴퓨터가 직접 이해하고 실행할 수 있는 언어는 저급 언어
- 고급 언어로 작성된 소스 코드가 실행되기 위해서는 저급 언어로 변환되어야 한다.

**저급 언어**
- 저급 언어에는 기계어와 어셈블리어가 있다.
- 기계어: 0과 1의 명령어 비트로 이루어진 언어
- 어셈블리어: 기계어를 읽기 편한 형태로 번역한 언어

**고급 언어**
- 고급 언어를 저급 언어로 변환하는 방식에는 크게 컴파일 방식과 인터프리트 방식이 있다.
- 컴파일 방식은 소스 코드 전체가 한번에 저급 언어로 변환되며 소스 코드 내에 오류가 하나라도 존재할 경우 컴파일에 실패한다.
- 컴파일 방식의 고급 언어인 컴파일 언어로 작성된 소스 코드를 저급 언어로 변환하는 과정을 컴파일이라고 하며 컴파일을 수행하는 도구를 컴파일러라고 한다.
- 컴파일러를 통해 저급 언어로 변환된 코드를 목적 코드라고 한다.
- 인터프리트 방식은 소스 코드를 한줄씩 저급 언어로 변환하며 실행하는 방식으로 소스 코드에 오류가 있더라도 해당 오류 이전의 코드까지는 정상적으로 실행된다.

### 명령어의 구조
- 명령어는 연산 코드와 오퍼랜드로 구성된다.
- 명령어가 수행할 연산을 연산 코드(operation code)라 하고 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 오퍼랜드(operand)라고 한다.

**연산 코드**
- 연산 코드 유형은 크게 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어가 있다.
- 데이터 전송: MOVE, STORE, LOAD(FETCH), PUSH, POP …
- 산술/논리 연산: ADD, SUB, MUL, DIV, INC, DEC, AND, OR, NOT, COMPARE …
- 제어 흐름 변경: JUMP, CONDITIONAL JUMP, HALT, CALL, RETURN …
- 입출력 제어: READ, WRITE, START IO, TEST IO …

**오퍼랜드**
- 명령어 중 오퍼랜드가 속한 영역을 오퍼랜드 필드라고 한다.
- 오퍼랜드 필드에는 보통 연산에 사용할 데이터를 직접 명시하기 보다는 데이터가 저장된 위치, 즉 메모리 주소나 레지스터의 이름이 담기기 때문에 주소 필드라고 부르기도 한다.
- 오퍼랜드는 명령어 안에 n개 존재할 수 있으며 n개의 오퍼랜드가 있는 명령어를 n-주소 명령어라고 한다.
- 오퍼랜드 필드에 데이터를 직접 명시하는 경우 명령의 처리 속도를 높일 수 있지만 명령어의 길이가 제한 되어 있기 때문에 명령어의 오퍼랜드 필드로 표현할 수 있는 정보가 크지 않다.
- 따라서 오퍼랜드 필드의 크기보다 더 큰 데이터가 필요할 경우에 오퍼랜드 필드에 메모리의 주소를 담는다.
- 유효 주소: 연산 코드에 사용할 데이터가 저장된 위치
- 주소 지정 방식: 유효 주소를 찾는 방법
    - 즉시 주소 지정 방식: 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
    - 직접 주소 지정 방식: 데이터가 담긴 메모리 주소를 직접적으로 명시
    - 간접 주소 지정 방식: 유효 주소가 담긴 메모리의 주소를 명시
    - 레지스터 주소 지정 방식: 데이터가 담긴 레지스터의 주소를 명시
    - 레지스터 간접 주소 지정 방식: 유효 주소가 담긴 레지스터의 이름을 명시